\documentclass[]{report}
\usepackage{graphicx}
\graphicspath{ {./res/} }


% Title Page
\title{RobotRace}
\author{Stefano Salvatori, Riccardo Salvatori}


\begin{document}
\maketitle

\section{Introduzione}

\section{Motor Schema}
 Per l'implementazione attraverso motor schema si è deciso di implementare 3 comportamenti principali: "go foreword", "stay on path" e "avoid obstacoles", associando ad ognuno il relativo campo di forze.
 Ogni campo genera un vettore di lunghezza compresa tra 0 e 1; i valori vengono poi combinati per generare il vettore risultante che determinerà la  velocità traslazionale ed angolare del robot.
 Per determinare i valori di rotazione delle ruote (destra e sinistra), è necessario passare dal modello traslazionale a quello differenziale, attraverso le formule:
 
 \subsection{Go Foreword}
 
 Per implementare questo comportamento viene specificato un campo "uniforme" direzionato veso la meta, permettendo al robot di muoversi verso di essa.
 L'intensità dal campo è costante, la direzione assoluta è costane ma, essendo calcolata sul riferimento del robot, dipende dall'orientamento relativo del footbot.

$$
V_{angle} = 0
$$
$$
V_{length} = C
$$

 
 
 \subsection{Stay On Path} 
 Definisce un campo di forza "perpendicolare" ai muri del tracciato. Permette al robot di rimanere all'interno del percorso.
 Viene utilizzato il \textit{distance scanner} per misurare la distanza dai muri così da determinare l'intensità del campo.
 Il sensore di distanza genere 24 coppiedistanze-angolo, 12 long range e 12 short range. I valori di distanza vengono scalati in un valore tra 0 e 1 e combinati in un singolo vettore. La lunghezza del vettore viene scalata anch'essa tra 0 e 1.
 
 $$
 V_{angle} = -\frac{\pi}{2}
 $$
 $$
 V_{length} = \left\{\begin{array}{lr}
 \frac{D-d}{D} & \text{for } d \leq D\\
 1 & \text{for } d $>$ D
 \end{array}\right\}
 $$
 
 
 \subsection{Avoid Obstacoles} 
 Definisce un campo "tangenziale" in presenza di ostacoli, permettendo al robot di aggirarli.
 Per misurare l'intensità e la direzione del campo viene utilizzato il \textit{proximity sensor}.
 Il sensore di distanza genere 24 coppie prossimità-angolo. Da queste viene generato un singolo vettore con lunghezza compresa tra 0 e 1.
 
  $$
 V_{angle} = \frac{\pi}{2} + \alpha
 $$
 $$
 V_{length} = p
 $$
 
 
 
 

\section{Controller Genetico}
\subsection{Architettura}
Per il controller genetico abbiamo deciso, ispirandoci al lavoro di \textit{Floreano e Mandola} \cite{genetic_evolution_nn},  di utilizzare una rete neurale addestrata con un algoritmo genetico. In particolare in questo caso il robot viene controllato da una rete composta da 24 neuroni di input completamente connessi a 2 neuroni di output come mostrato in figura \ref{fig:genetic_network}.
Gli input vengono letti da 12 sensori di distanza accoppiati ognuno con il suo angolo (ricordiamo che l'angolo varia visto che il sensore di distanza ruota ad una certa velocità sul footbot) mentre gli output rappresentano la velocità da assegnare alle ruote. Sia i valori degli input relativi alle distanze che i valori di output sono stati normalizzati nell'intervallo [0,1]; gli angoli sono invece stati inseriti in radianti con valori in [-$\pi$, $\pi$]
\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{genetic_network.png}
\caption{Schema della rete neurale che controlla il robot. I 2 neuroni di ouput rappresentano la velocità delle ruote mentre gli input vengono letti da 12 sensori di distanza: ogni valore del sensore viene passato con il suo angolo. }
\label{fig:genetic_network}
\end{figure}

\subsection{Algoritmo Genetico}
Per l'implementazione dell'algoritmo genetico il genoma di ogni individuo viene rappresentato da un array di 50 numeri reali ((24 input + 1 bias) * 2  output = 50) nell'intervallo [-15, 15] corrispondenti ai pesi della rete. Sono stati utilizzati solo 12 dei 24 sensori presenti nel footbot per ridurre lo spazio di ricerca dell'algoritmo: utilizzarli tutti avrebbe richiesto infatti una rete composta da 98 pesi ((48+1)*2) riducendo notevolmente le performance sia in termini di tempi di esecuzione che di convergenza.

Per quanto riguarda l'evoluzione abbiamo utilizzato un approccio di tipo SteadyState in cui, ad ogni generazione, solo una certa pecentuale di individui viene sostituita dai nuovi ottenuti dalla prodecura di crossover e mutazione. Nel nostro caso in particolare la popolazione è composta da un totale di 50 individui e una percentuale di rimpiazzo pari al 50\%.  Abbiamo scelto il meccanismo di \textit{Roulette Wheel} per la selezione e di \textit{Gaussian Mutation} per la mutazione.
Per quanto riguarda il crossover abbiamo invece sperimentato e confrontato 3 diverse modalità: 
\begin{itemize}
\item{OnePointCrossover}: Si sceglie a caso un punto sui cromosomi di entrambi i genitori detto "punto di crossover"; i valori a destra di quel punto vengono scambiati tra i due genitori generando 2 nuovi cromosomi figli.
\item{TwoPointCrossover}: Prevede di selezionare due punti di crossover: i valori tra i due punti vengono scambiati tra genitori.
\item{UniformCrossover}: Ognuno dei 2 figli ha una uguale probabilità di ereditare un certo gene da uno dei suoi genitori.
 \end{itemize}

La funzione di fitness di ogni individuo è la seguente

\[avgPerformance * \dfrac{1}{1+distance}\]

E composta dal prodotto di due termini: il primo che misura la performance media del robot in termini di velocità mantenuta durante il percorso e ostacoli evitati; la seconda che misura la distanza dall'arrivo. In particolare la performance media è calcolata suddividendo l'esperimento in slot temporali di lubghezza M per ognuno dei quali si calcola la seguente grandezza

\[(1-i)^2 * |\dfrac{(V_L+V_R)}{2}| * \dfrac{1}{1+|V_R-V_L|}\]

\subsection{Test e Risultati}

Per ogni individuo nella popolazione sono stati eseguite 5 simulazioni

I parametri utilizzati nei vari test sono:
Number of generations 500
Population size 50
Mutation probability 0.05
Crossover probability 0.8
Replacement percentage 0.5

Per l'implementazione del codice in C++ è stata utilizzata la libreria GAlib\footnote{http://lancet.mit.edu/galib-2.4/} che mette a disposizione diverse funzionalità relative ai principali meccanismi degli algoritmi genetici.




\bibliographystyle{unsrt}
\bibliography{bibliografia}

\end{document}          
